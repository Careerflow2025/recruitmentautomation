-- =====================================================
-- FIX CONVERSATION LOCKS TABLE ISSUE
-- =====================================================
-- This script fixes the missing conversation_locks table error
-- Run this in your Supabase SQL Editor
-- =====================================================

-- 1. CREATE CONVERSATION_LOCKS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.conversation_locks (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'idle' NOT NULL CHECK (status IN ('idle', 'processing')),
  started_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  ended_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_conversation_locks_user_id ON public.conversation_locks(user_id);
CREATE INDEX IF NOT EXISTS idx_conversation_locks_status ON public.conversation_locks(status);
CREATE INDEX IF NOT EXISTS idx_conversation_locks_updated_at ON public.conversation_locks(updated_at);

-- Enable RLS for multi-tenant isolation
ALTER TABLE public.conversation_locks ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversation_locks
CREATE POLICY "Allow authenticated user access" ON public.conversation_locks
  FOR ALL USING (auth.uid() = user_id);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.set_current_timestamp_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for auto-updating updated_at
CREATE TRIGGER IF NOT EXISTS handle_updated_at
  BEFORE UPDATE ON public.conversation_locks
  FOR EACH ROW
  EXECUTE FUNCTION public.set_current_timestamp_updated_at();

-- 2. CREATE FUNCTION TO UNLOCK STALE LOCKS
-- =====================================================
CREATE OR REPLACE FUNCTION public.unlock_stale_conversation_locks()
RETURNS INTEGER AS $$
DECLARE
  unlocked_count INTEGER;
BEGIN
  -- Unlock locks older than 5 minutes that are still 'processing'
  UPDATE public.conversation_locks
  SET status = 'idle',
      ended_at = NOW(),
      updated_at = NOW()
  WHERE status = 'processing'
    AND updated_at < NOW() - INTERVAL '5 minutes';
  
  GET DIAGNOSTICS unlocked_count = ROW_COUNT;
  
  RETURN unlocked_count;
END;
$$ LANGUAGE plpgsql;

-- 3. ADD MISSING USER_ID COLUMN TO MATCH_STATUSES (if needed)
-- =====================================================
ALTER TABLE public.match_statuses 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Create index for user_id in match_statuses
CREATE INDEX IF NOT EXISTS idx_match_statuses_user_id ON public.match_statuses(user_id);

-- Update RLS policy for match_statuses to use user_id
DROP POLICY IF EXISTS "Allow all operations on match_statuses" ON public.match_statuses;
DROP POLICY IF EXISTS "Users can view their own match_statuses" ON public.match_statuses;

-- Enhanced RLS policies for match_statuses
CREATE POLICY "Users can view their own match_statuses" ON public.match_statuses
  FOR SELECT USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_statuses.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own match_statuses" ON public.match_statuses
  FOR INSERT WITH CHECK (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_statuses.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own match_statuses" ON public.match_statuses
  FOR UPDATE USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_statuses.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete their own match_statuses" ON public.match_statuses
  FOR DELETE USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_statuses.candidate_id AND c.user_id = auth.uid()
    )
  );

-- 4. ADD MISSING USER_ID COLUMN TO MATCH_NOTES (if needed)
-- =====================================================
ALTER TABLE public.match_notes 
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Create index for user_id in match_notes
CREATE INDEX IF NOT EXISTS idx_match_notes_user_id ON public.match_notes(user_id);

-- Update RLS policy for match_notes to use user_id
DROP POLICY IF EXISTS "Allow all operations on match_notes" ON public.match_notes;
DROP POLICY IF EXISTS "Users can view their own match_notes" ON public.match_notes;

-- Enhanced RLS policies for match_notes
CREATE POLICY "Users can view their own match_notes" ON public.match_notes
  FOR SELECT USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_notes.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own match_notes" ON public.match_notes
  FOR INSERT WITH CHECK (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_notes.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own match_notes" ON public.match_notes
  FOR UPDATE USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_notes.candidate_id AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete their own match_notes" ON public.match_notes
  FOR DELETE USING (
    user_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM public.candidates c 
      WHERE c.id = match_notes.candidate_id AND c.user_id = auth.uid()
    )
  );

-- 5. ADD COMMENTS FOR DOCUMENTATION
-- =====================================================
COMMENT ON TABLE public.conversation_locks IS 'Manages conversation session locks to prevent concurrent AI requests per user';
COMMENT ON COLUMN public.conversation_locks.user_id IS 'User who owns the conversation session';
COMMENT ON COLUMN public.conversation_locks.status IS 'Lock status: idle or processing';
COMMENT ON COLUMN public.conversation_locks.started_at IS 'When the lock was acquired';
COMMENT ON COLUMN public.conversation_locks.ended_at IS 'When the lock was released';

-- =====================================================
-- FIX COMPLETE!
-- =====================================================
-- This script:
-- ✅ Creates the missing conversation_locks table
-- ✅ Sets up proper RLS policies for multi-tenant isolation
-- ✅ Adds auto-unlock function for stale locks
-- ✅ Ensures match_statuses and match_notes have user_id columns
-- ✅ Updates RLS policies for proper tenant isolation
-- 
-- Your AI assistant should now work without the table error!
-- =====================================================